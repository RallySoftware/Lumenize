<!DOCTYPE html>

<html>
<head>
  <title>ChartTimeIteratorAndRange.coffee</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <link rel="stylesheet" media="all" href="resources/base.css" />
  <link rel="stylesheet" media="all" href="resources/module.css" />
</head>
<body>
  <header>
    <h1>ChartTimeIteratorAndRange.coffee</h1>
  </header>
  <div id="content">
    <div id="sidebar">
      
      <h4>Classes</h4>
      <ul class="classlist">
        
        <li><a href="#ChartTimeIterator">ChartTimeIterator</a></li>
        
        <li><a href="#ChartTimeRange">ChartTimeRange</a></li>
        
      </ul>
      
      
    </div>
    <div id="main">
      
      
      <div id="classes">
        <h2>Classes</h2>
        
        <div class="class">
          <div class="header">
            <a id="ChartTimeIterator"><h3>ChartTimeIterator</h3></a>
            
          </div>
          <div class="class_content">
            <h1>ChartTimeIterator</h1>

<p>Iterate through days, months, years, etc. skipping weekends and holidays that you 
specify. It will also iterate over hours, minutes, seconds, etc. and skip times that are not
between the specified work hours.</p>

<h2>Usage</h2>

<pre><code>{ChartTimeIterator, ChartTimeRange, ChartTime} = require('../')

ChartTime.setTZPath('../vendor/tz')

cti = new ChartTimeIterator({
  start:new ChartTime({granularity: 'day', year: 2009, month:1, day: 1}),
  pastEnd:new ChartTime({granularity: 'day', year: 2009, month:1, day: 8}),
  workDays: 'Monday, Tuesday, Wednesday, Thursday, Friday',
  holidays: [
    {month: 1, day: 1},  # New Years day was a Thursday in 2009
    {year: 2009, month: 1, day: 2}  # Also got Friday off in 2009
  ]
})

while (cti.hasNext())
  console.log(cti.next().toString())

# 2009-01-05
# 2009-01-06
# 2009-01-07
</code></pre>
            <div class="methods">
              
              
              <div class="instancemethods">
                <h3>Instance Methods</h3>
                
                <div class="method">
                  <h4>constructor(ctr, @emit, @childGranularity, tz)</h4>
                  <ul>
<li><strong>ctr</strong> is a ChartTimeRange or a raw Object with all the necessary properties to be a spec for a new ChartTimeRange.
Using a ChartTimeRange is now the preferred method. The raw Object is supported for backward compatibility.</li>
<li><strong>emit</strong> is an optional String that specifies what should be emitted. Possible values are 'ChartTime' (default),
'ChartTimeRange', and 'Date' (javascript Date Object). Note, to maintain backward compatibility with the time
before ChartTimeRange existed, the default for emit when instantiating a new ChartTimeIterator directly is 
'ChartTime'. However, if you request a new ChartTimeIterator from a ChartTimeRange object using getIterator(),
the default is 'ChartTimeRange'.</li>
<li><strong>childGranularity</strong> When emit is 'ChartTimeRange', this is the granularity for the start and pastEnd of the
ChartTimeRange that is emitted.</li>
<li><strong>tz</strong> is a Sting specifying the timezone in the standard form,<code>America/New_York</code> for example.</li>
</ul>

<p>Note, skip is assumed to be 1 or -1 for emitted ChartTimeRanges</p>
                </div>
                
                <div class="method">
                  <h4>startOver()</h4>
                  <p>Will go back to the where the iterator started.</p>
                </div>
                
                <div class="method">
                  <h4>hasNext()</h4>
                  <p>Returns true if there are still things left to iterator over. Note that if there are holidays, weekends or non-workhours to skip,
then hasNext() will take that into account. For example if the pastEnd is a Sunday, hasNext() will return true the next
time it is called after the Friday is emitted.</p>
                </div>
                
                <div class="method">
                  <h4>next()</h4>
                  <p>Emits the next value of the iterator. The start will be the first value emitted unless it should be skipped due
to holiday, weekend, or workhour knockouts.</p>
                </div>
                
                <div class="method">
                  <h4>getAll()</h4>
                  <p>Returns all values as an array.</p>
                </div>
                
                <div class="method">
                  <h4>getChartTimeInStateCalculator(tz)</h4>
                  
                </div>
                
              </div>
              
            </div>
          </div>
        </div>
        
        <div class="class">
          <div class="header">
            <a id="ChartTimeRange"><h3>ChartTimeRange</h3></a>
            
          </div>
          <div class="class_content">
            <h1>ChartTimeRange</h1>

<p>Allows you to specify a range for iterating over or identifying if it <code>contains()</code> some other date.
This <code>contains()</code> comparision can be done in a timezone sensitive way.</p>

<h2>Usage</h2>

<p>Let's create the <code>spec</code> for our ChartTimeRange</p>

<pre><code>{ChartTimeIterator, ChartTimeRange, ChartTime} = require('../')

ChartTime.setTZPath('../vendor/tz')

r = new ChartTimeRange({
  start:new ChartTime('2011-01-02'),
  pastEnd:new ChartTime('2011-01-07'),
  holidays: [
    {month: 1, day: 1},  # Notice the lack of a year specification
    {year: 2011, month: 1, day: 2}  # Got January 2 off also in 2011
  ]
})
</code></pre>

<p><code>workDays</code> is already defaulted but you could have overridden it.</p>

<pre><code>console.log(r.workDays)
# [ 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday' ]
</code></pre>

<p>Now let's get an iterator over this range.</p>

<pre><code>i = r.getIterator('ChartTime')

while i.hasNext()
  console.log(i.next().toString()) 

# 2011-01-03
# 2011-01-04
# 2011-01-05
# 2011-01-06
</code></pre>

<p>Notice how 2011-01-02 was skipped because it was a holiday. Also notice how the pastEnd is not included.
Ranges are inclusive of the start and exclusive of the pastEnd. This allows the pastEnd of one to be
the start of the next with no overlap or gap. This focus on precision pervades the design of the ChartTime library.</p>

<p>Now, let's create a ChartTimeRange with <code>hour</code> granularity to elaborate on this inclusive/exclusive behavior.</p>

<pre><code>r2 = new ChartTimeRange({
  start:new ChartTime('2011-01-02T00'),
  pastEnd:new ChartTime('2011-01-07T00'),
})
</code></pre>

<p><code>start</code> is inclusive.</p>

<pre><code>console.log(r2.contains(new ChartTime('2011-01-02T00')))
# true
</code></pre>

<p>But <code>pastEnd</code> is exclusive</p>

<pre><code>console.log(r2.contains(new ChartTime('2011-01-07T00')))
# false
</code></pre>

<p>But just before <code>pastEnd</code> is OK</p>

<pre><code>console.log(r2.contains('2011-01-06T23'))
# true
</code></pre>

<p>In the above line, notice how we omitted the <code>new ChartTime(...)</code>. If you pass in a string without a timezone, 
it will automatically create the ChartTime to do the comparison.</p>

<p>All of the above comparisons assume that the <code>start</code>/<code>pastEnd</code> boundaries are in the same timezone as the contains date.</p>

<h2>Timezone sensitive comparisions</h2>

<p>Now, let's look at how you do timezone sensitive comparisions.</p>

<p>Note, you must set the path to the tz files with <code>ChartTime.setTZPath('path/to/tz/files')</code> before you do timezone 
sensitive comparisions.</p>

<p>If you pass in a timezone, then it will shift the CharTimeRange boundaries to that timezone to compare to the 
date/timestamp that you pass in. This system is optimized to the pattern where you first define your boundaries without regard 
to timezone. Christmas day is a holiday in any timezone. Saturday and Sunday are non work days in any timezone. The iteration
starts on July 10th; etc. THEN you have a bunch of data that you have stored in a database in GMT. Maybe you've pulled
it down from an API but the data is represented with a GMT date/timestamp. You then want to decide if the GMT date/timestamp 
is contained within the iteration as defined by a particular timezone, or is a Saturday, or is during workhours, etc. 
The key concept to remember is that the timebox boundaries are shifted NOT the other way around. It says at what moment
in time July 10th starts in a particular timezone and internally represents that in a way that can be compared to a GMT 
date/timestamp.</p>

<p>So, when it's 3am in GMT on 2011-01-02, it's still 2011-01-01 in New York. Using the above <code>r2</code> range, we say:</p>

<pre><code>console.log(r2.contains('2011-01-02T03:00:00.000Z', 'America/New_York'))
# false
</code></pre>

<p>But it's still 2011-01-06 in New York, when it's 3am in GMT on 2011-01-07</p>

<pre><code>console.log(r2.contains('2011-01-07T03:00:00.000Z', 'America/New_York'))
# true
</code></pre>

<p>Now, let's explore how ChartTimeRanges and ChartTimeIterators are used together. Here is a range spec.</p>

<pre><code>r3 = new ChartTimeRange({
  start:new ChartTime('2011-01-06'),
  pastEnd:new ChartTime('2011-01-11'),
  startWorkTime: {hour: 9, minute: 0},
  pastEndWorkTime: {hour: 11, minute: 0}  # Very short work day for demo purposes
})
</code></pre>

<p>You can ask for an iterator to emit ChartTimeRanges rather than ChartTime values. On each call to <code>next()</code>, the
iterator will give you a new ChartTimeRange with the <code>start</code> value set to what you would have gotten had you 
requested that it emit ChartTimes. The `pastEnd' of the emitted ChartTimeRange will be set to the following value.
This is how you drill-down from one granularity into a lower granularity.</p>

<p>By default, the granularity of the iterator will equal the <code>start</code>/<code>pastEnd</code> of the original ChartTimeRange. 
However, you can provide a different granularity (<code>hour</code> in the example below) for the iterator if you want 
to drill-down at a lower granularity.</p>

<pre><code>i3 = r3.getIterator('ChartTimeRange', 'hour')

while i3.hasNext()
  subRange = i3.next()
  console.log("Sub range goes from #{subRange.start.toString()} to #{subRange.pastEnd.toString()}")
  subIterator = subRange.getIterator('ChartTime')
  while subIterator.hasNext()
    console.log('    Hour: ' + subIterator.next().hour)

# Sub range goes from 2011-01-06T00 to 2011-01-07T00
#     Hour: 9
#     Hour: 10
# Sub range goes from 2011-01-07T00 to 2011-01-10T00
#     Hour: 9
#     Hour: 10
# Sub range goes from 2011-01-10T00 to 2011-01-11T00
#     Hour: 9
#     Hour: 10
</code></pre>

<p>There is a lot going on here, so let's poke at it a bit. First, notice how the second sub-range goes from the 7th to the
10th. That's because there was a weekend in there. We didn't get hours for the Saturday and Sunday.</p>

<p>The above approach (<code>r3</code>/<code>i3</code>) is useful for some forms of hand generated analysis, but if you are using ChartTime with 
Lumenize, it's overkill because Lumenize is smart enough to do rollups based upon the segments that are emitted from the
lowest granularity ChartTime. So you can just iterate over the lower granularity and Lumenize will automatically manage 
the drill up/down to day/month/year levels automatically.</p>

<pre><code>r4 = new ChartTimeRange({
  start:'2011-01-06T00',  # Notice how we include the hour now
  pastEnd:'2011-01-11T00',
  startWorkTime: {hour: 9, minute: 0},
  pastEndWorkTime: {hour: 11, minute: 0}  # Very short work day for demo purposes
})
</code></pre>

<p>Notice how we are able to simply use strings to represent the start/pastEnd dates. ChartTimeRange automatically constructs 
ChartTime objects from those strings. We could have done that in the earlier examples. I chose not to do so to illustrate
how ChartTimes are used under the covers.</p>

<pre><code>i4 = r4.getIterator('ChartTime')

while i4.hasNext()
  console.log(i4.next().toString())

# 2011-01-06T09
# 2011-01-06T10
# 2011-01-07T09
# 2011-01-07T10
# 2011-01-10T09
# 2011-01-10T10
</code></pre>

<p><code>r4</code>/<code>i4</code> covers the same ground as <code>r3</code>/<code>i3</code> but without the explicit nesting.</p>
            <div class="methods">
              
              
              <div class="instancemethods">
                <h3>Instance Methods</h3>
                
                <div class="method">
                  <h4>constructor(spec)</h4>
                  <p>spec can have the following properties:</p>

<ul>
<li><strong>start</strong> is a ChartTime object or a string. The first value that next() returns.</li>
<li><strong>pastEnd</strong> is a ChartTime object or string. Must match granularity. hasNext() returns false when current is here or later.</li>
<li><strong>skip</strong> is an optional num. Defaults to 1 or -1. Use -1 to march backwards from pastEnd - 1. Currently any
values other than 1 and -1 give unexpected behavior.</li>
<li><strong>granularity</strong> is used to determine the granularity that you will iterate over. Note, you can have granularity of say month 
for the start and/or pastEnd but have a finer granularity for the range. Let's say you want to iterate over all the days
of the current month. In this case, pastEnd would be 'next month', and start would be 'prior month'.</li>
<li><strong>limit</strong> you can specify limit plus one of start/pastEnd and only get back this many.</li>
<li><strong>workDays</strong> list of days of the week that you work on. Either ['Monday', 'Tuesday', ...] or "Monday,Tuesday,..."
Defaults to ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday'].</li>
<li><strong>holidays</strong> is an optional Array like: [{month: 12, day: 25}, {year: 2011, month: 11, day: 24}]. Notice how
you can leave off the year if the holiday falls on the same day every year.</li>
<li><strong>startWorkTime</strong> is an optional object in the form {hour: 8, minute: 15}. Must include minute even when 0.
If startWorkTime is later than pastEndWorkTime, then it assumes that you work the night shift and your work
hours span midnight.</li>
<li><strong>pastEndWorkTime</strong> is an optional object in the form {hour: 17, minute: 0}. Must include minute even when 0.
The use of startWorkTime and pastEndWorkTime only make sense when the granularity is "hour" or finer.
Note: If the business closes at 5:00pm, you'll want to leave pastEndWorkTime to 17:00, rather
than 17:01. Think about it, you'll be open 4:59:59.999pm, but you'll be closed at 5:00pm. This also makes all of
the math work. 9am to 5pm means 17 - 9 = an 8 hour work day.</li>
</ul>
                </div>
                
                <div class="method">
                  <h4>getIterator(emit, childGranularity, tz)</h4>
                  <p>Returns a new ChartTimeIterator using this ChartTimeRange as the boundaries.</p>

<p>Note, to maintain backward compatibility with the time before ChartTimeRange existed, the default for emit when 
instantiating a new ChartTimeIterator directly is 'ChartTime'. However, if you request a new ChartTimeIterator 
from a ChartTimeRange object using getIterator(), the default is 'ChartTimeRange'.</p>
                </div>
                
                <div class="method">
                  <h4>getAll(emit, childGranularity, tz)</h4>
                  <p>Returns all of the points in the timeline specified by this ChartTimeRange.</p>

<p>Note, to maintain backward compatibility with the time before ChartTimeRange existed, the default for emit when 
instantiating a new ChartTimeIterator directly is 'ChartTime'. However, if you request a new ChartTimeIterator 
from a ChartTimeRange object using getIterator(), the default is 'ChartTimeRange'.</p>
                </div>
                
                <div class="method">
                  <h4>getTimeline()</h4>
                  <p>Returns all of the points in the timeline specified by this ChartTimeRange as ChartTime objects.</p>
                </div>
                
                <div class="method">
                  <h4>contains(date, tz)</h4>
                  <p>True if the date provided is within this ChartTimeRange.</p>

<p><strong>date</strong> can be either a JavaScript date object or an ISO-8601 formatted string.</p>

<h2>Usage:</h2>

<p>We can create a range from May to July.</p>

<pre><code>r = new ChartTimeRange({
  start: '2011-05',
  pastEnd: '2011-07'
})

console.log(r.contains('2011-06-15T12:00:00.000Z', 'America/New_York'))
# true
</code></pre>
                </div>
                
              </div>
              
            </div>
          </div>
        </div>
        
      </div>
      
      
    </div>
  </div>
</body>
</html>
