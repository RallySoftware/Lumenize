<!DOCTYPE html>

<html>
<head>
  <title>dataTransform.coffee</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <link rel="stylesheet" media="all" href="resources/base.css" />
  <link rel="stylesheet" media="all" href="resources/module.css" />
</head>
<body>
  <header>
    <h1>dataTransform.coffee</h1>
  </header>
  <div id="content">
    <div id="sidebar">
      
      
      <h4>Functions</h4>
      <ul class="functionlist">
        
        <li><a href="#csvStyleArray_To_ArrayOfMaps">csvStyleArray_To_ArrayOfMaps</a></li>
        
        <li><a href="#snapshotArray_To_AtArray">snapshotArray_To_AtArray</a></li>
        
        <li><a href="#groupByAtArray_To_HighChartsSeries">groupByAtArray_To_HighChartsSeries</a></li>
        
        <li><a href="#aggregationAtArray_To_HighChartsSeries">aggregationAtArray_To_HighChartsSeries</a></li>
        
      </ul>
      
    </div>
    <div id="main">
      
      
      
      <div id="functions">
        <h2>Functions</h2>
        
        <div class="function">
          <div class="header">
            <a id="csvStyleArray_To_ArrayOfMaps"><h3>csvStyleArray_To_ArrayOfMaps(csvStyleArray, rowKeys)</h3></a>
          </div>
          
          <div>
            <p>@method csvStyleArray<em>To</em>ArrayOfMaps
@param {Array of Arrays} csvStyleArray The first row is usually the list of column headers but if not, you can
  provide your own such list in the second parameter
@param {Array} [rowKeys] specify the column headers like <code>['column1', 'column2']</code>. If not provided, it will use
  the first row of the csvStyleArray</p>

<p><code>csvStyleArry_To_ArryOfMaps</code> is a convenience function that will convert a csvStyleArray like:</p>

<pre><code>{csvStyleArray_To_ArrayOfMaps} = require('../')

csvStyleArray = [
  ['column1', 'column2'],
  [1         , 2       ],
  [3         , 4       ],
  [5         , 6       ]
]
</code></pre>

<p>to an Array of Maps like this:</p>

<pre><code>console.log(csvStyleArray_To_ArrayOfMaps(csvStyleArray))

# [ { column1: 1, column2: 2 },
#   { column1: 3, column2: 4 },
#   { column1: 5, column2: 6 } ]
</code></pre>

<p>`</p>
          </div>
          
        </div>
        
        <div class="function">
          <div class="header">
            <a id="snapshotArray_To_AtArray"><h3>snapshotArray_To_AtArray(snapshotArray, listOfAtCTs, validFromField, uniqueIDField, tz, validToField)</h3></a>
          </div>
          
          <div>
            <p>@method snapshotArray<em>To</em>AtArray
@param {Array} snapshotArray Array of snapshots sorted by validFromField # !TODO: Add the sort. Borrow from TimeInState.
@param {Array} atArray Array of ChartTime objects representing the moments we want the snapshots at
@param {String} validFromField Specifies the field that holds a date string in ISO-8601 canonical format (eg <code>2011-01-01T12:34:56.789Z</code>)
@param {String} validToField Same except for the end of the snapshot's active time.
  Defaults to '_ValidTo' for backward compatibility reasons.
@param {String} uniqueIDField Specifies the field that holds the unique ID. Note, no matter the input type, they will come
   out the other side as Strings. I could fix this if it ever became a problem.
@param {String} tz</p>

<p>If you have a list of snapshots representing the changes in a set of work items over time, this function will return the state of
each item at each moments of interest. It's useful for time-series charts where you have snapshot or change records but you need to know
the values at particular moments in time (the times in listOfAtCTs).</p>

<p>Since this transformation is timezone dependent, you'll need to initialize ChartTime with the path to the tz files.
Note, that if you use the browserified version of Lumenize, you still need to call setTZPath with some dummy path.
I'm hoping to fix this at some point.</p>

<pre><code>{snapshotArray_To_AtArray, ChartTime} = require('../')
</code></pre>

<p>It will convert an snapshotArray like:</p>

<pre><code>snapshotArray = [
  {_ValidFrom: '1999-01-01T12:00:00.000Z', _ValidTo:'2010-01-02T12:00:00.000Z', ObjectID: 0, someColumn: 'some value'},
  {_ValidFrom: '2011-01-01T12:00:00.000Z', _ValidTo:'2011-01-02T12:00:00.000Z', ObjectID: 1, someColumn: 'some value'},
  {_ValidFrom: '2011-01-02T12:00:00.000Z', _ValidTo:'9999-01-01T12:00:00.000Z', ObjectID: 2, someColumn: 'some value 2'},      
  {_ValidFrom: '2011-01-02T12:00:00.000Z', _ValidTo:'2011-01-03T12:00:00.000Z', ObjectID: 3, someColumn: 'some value'},
  {_ValidFrom: '2011-01-05T12:00:00.000Z', _ValidTo:'9999-01-01T12:00:00.000Z', ObjectID: 1, someColumn: 'some value'},
  {_ValidFrom: '2222-01-05T12:00:00.000Z', _ValidTo:'9999-01-01T12:00:00.000Z', ObjectID: 99, someColumn: 'some value'},
]
</code></pre>

<p>And a listOfAtCTs like:</p>

<pre><code>listOfAtCTs = [new ChartTime('2011-01-02'), new ChartTime('2011-01-03'), new ChartTime('2011-01-07')]
</code></pre>

<p>To an atArray with the value of each ObjectID at each of the points in the listOfAtCTs like:</p>

<pre><code>a = snapshotArray_To_AtArray(snapshotArray, listOfAtCTs, '_ValidFrom', 'ObjectID', 'America/New_York', '_ValidTo')

console.log(a)

# [ [ { _ValidFrom: '2011-01-01T12:00:00.000Z',
#       _ValidTo: '2011-01-02T12:00:00.000Z',
#       ObjectID: '1',
#       someColumn: 'some value' } ],
#   [ { _ValidFrom: '2011-01-02T12:00:00.000Z',
#       _ValidTo: '9999-01-01T12:00:00.000Z',
#       ObjectID: '2',
#       someColumn: 'some value 2' },
#     { _ValidFrom: '2011-01-02T12:00:00.000Z',
#       _ValidTo: '2011-01-03T12:00:00.000Z',
#       ObjectID: '3',
#       someColumn: 'some value' } ],
#   [ { _ValidFrom: '2011-01-05T12:00:00.000Z',
#       _ValidTo: '9999-01-01T12:00:00.000Z',
#       ObjectID: '1',
#       someColumn: 'some value' },
#     { _ValidFrom: '2011-01-02T12:00:00.000Z',
#       _ValidTo: '9999-01-01T12:00:00.000Z',
#       ObjectID: '2',
#       someColumn: 'some value 2' } ] ]
</code></pre>
          </div>
          
        </div>
        
        <div class="function">
          <div class="header">
            <a id="groupByAtArray_To_HighChartsSeries"><h3>groupByAtArray_To_HighChartsSeries(groupByAtArray, nameField, valueField, nameFieldValues, returnPreOutput)</h3></a>
          </div>
          
          <div>
            <p>@method groupByAtArray<em>To</em>HighChartsSeries
@param {Array} groupByAtArray result of calling groupByAt()
@param {String} nameField
@param {String} valueField
@pararm {Array} nameFieldValues
@param {Boolean} [returnPreOutput] if true, this function returns the map prior to squishing the name into the rows
@return {Array or Object}</p>

<p>Takes an array of arrays that came from groupByAt and looks like this:</p>

<pre><code>{groupByAtArray_To_HighChartsSeries} = require('../')

groupByAtArray = [
  [
    { 'CFDField': 8, KanbanState: 'Ready to pull' },
    { 'CFDField': 5, KanbanState: 'In progress' },
    { 'CFDField': 9, KanbanState: 'Accepted' },
  ],
  [
    { 'CFDField': 2, KanbanState: 'Ready to pull' },
    { 'CFDField': 3, KanbanState: 'In progress' },
    { 'CFDField': 17, KanbanState: 'Accepted' },
  ]
]
</code></pre>

<p>and optionally a list of nameFieldValues</p>

<pre><code>nameFieldValues = ['Ready to pull', 'In progress']  # Note, Accepted is missing
</code></pre>

<p>and extracts the <code>valueField</code> under nameField to give us this</p>

<pre><code>console.log(groupByAtArray_To_HighChartsSeries(groupByAtArray, 'KanbanState', 'CFDField', nameFieldValues))
# [ { name: 'Ready to pull', data: [ 8, 2 ] },
#   { name: 'In progress', data: [ 5, 3 ] } ]
</code></pre>
          </div>
          
        </div>
        
        <div class="function">
          <div class="header">
            <a id="aggregationAtArray_To_HighChartsSeries"><h3>aggregationAtArray_To_HighChartsSeries(aggregationAtArray, aggregationSpec)</h3></a>
          </div>
          
          <div>
            <p>@method aggregationAtArray<em>To</em>HighChartsSeries
@param {Array} aggregationAtArray
@param {Object} aggregationSpec You can use the same spec you useed to call aggregateAt() as long as it includes
  any yAxis specifications
@return {Array} in HighCharts form</p>

<p>Takes an array of arrays that came from a call to aggregateAt() and looks like this:</p>

<pre><code>{aggregationAtArray_To_HighChartsSeries} = require('../')

aggregationAtArray = [
  {"Series 1": 8, "Series 2": 5, "Series3": 10},
  {"Series 1": 2, "Series 2": 3, "Series3": 20}
]
</code></pre>

<p>and a list of series configurations</p>

<pre><code>aggregationSpec = [
  {name: "Series 1", yAxis: 1},
  {name: "Series 2"}
]
</code></pre>

<p>and extracts the data into seperate series</p>

<pre><code>console.log(aggregationAtArray_To_HighChartsSeries(aggregationAtArray, aggregationSpec))
# [ { name: 'Series 1', data: [ 8, 2 ], yAxis: 1 },
#   { name: 'Series 2', data: [ 5, 3 ] } ]
</code></pre>

<p>Notice how the extra fields from the series array are included in the output.</p>
          </div>
          
        </div>
        
      </div>
      
    </div>
  </div>
</body>
</html>
