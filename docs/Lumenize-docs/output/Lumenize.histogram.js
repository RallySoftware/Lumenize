Ext.data.JsonP.Lumenize_histogram({"tagname":"class","name":"Lumenize.histogram","extends":null,"mixins":[],"alternateClassNames":[],"aliases":{},"singleton":false,"requires":[],"uses":[],"enum":null,"override":null,"inheritable":null,"inheritdoc":null,"meta":{},"private":null,"id":"class-Lumenize.histogram","members":{"cfg":[],"property":[],"method":[{"name":"clipping","tagname":"method","owner":"Lumenize.histogram","meta":{},"id":"method-clipping"}],"event":[],"css_var":[],"css_mixin":[]},"linenr":6,"files":[{"filename":"histogram.coffee.js","href":"histogram.coffee.html#Lumenize-histogram"}],"html_meta":{},"statics":{"cfg":[],"property":[],"method":[{"name":"bucket","tagname":"method","owner":"Lumenize.histogram","meta":{"static":true},"id":"static-method-bucket"},{"name":"getBuckets","tagname":"method","owner":"Lumenize.histogram","meta":{"static":true},"id":"static-method-getBuckets"},{"name":"histogramFromBuckets","tagname":"method","owner":"Lumenize.histogram","meta":{"static":true},"id":"static-method-histogramFromBuckets"}],"event":[],"css_var":[],"css_mixin":[]},"component":false,"superclasses":[],"subclasses":[],"mixedInto":[],"parentMixins":[],"html":"<div><pre class=\"hierarchy\"><h4>Files</h4><div class='dependency'><a href='source/histogram.coffee.html#Lumenize-histogram' target='_blank'>histogram.coffee.js</a></div></pre><div class='doc-contents'><p>Rules about dependencies:</p>\n\n<ul>\n<li>If a function can be calculated incrementally from an oldResult and newValues, then you do not need to specify dependencies</li>\n<li>If a funciton can be calculated from other incrementally calculable results, then you need only specify those dependencies</li>\n<li>If a function needs the full list of values to be calculated (like percentile coverage), then you must specify 'values'</li>\n<li>To support the direct passing in of OLAP cube cells, you can provide a prefix (field name) so the key in dependentValues\ncan be generated</li>\n<li>'count' is special and does not use a prefix because it is not dependent up a particular field</li>\n<li>You should calculate the dependencies before you calculate the thing that is depedent. The OLAP cube does some\nchecking to confirm you've done this.</li>\n</ul>\n\n</div><div class='members'><div class='members-section'><h3 class='members-title icon-method'>Methods</h3><div class='subsection'><div class='definedBy'>Defined By</div><h4 class='members-subtitle'>Instance Methods</h3><div id='method-clipping' class='member first-child not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='Lumenize.histogram'>Lumenize.histogram</span><br/><a href='source/histogram.coffee.html#Lumenize-histogram-method-clipping' target='_blank' class='view-source'>view source</a></div><a href='#!/api/Lumenize.histogram-method-clipping' class='name expandable'>clipping</a>( <span class='pre'>rows, valueField, [noClipping]</span> ) : Object[]</div><div class='description'><div class='short'>Note: The calling pattern and functionality of this method is legacy and a bit different from the other members of\nth...</div><div class='long'><p>Note: The calling pattern and functionality of this method is legacy and a bit different from the other members of\nthis histogram module. I just haven't yet had the opportunity to upgrade it to the new pattern.</p>\n\n<p>This histogram function is designed to work with data that is zero bound on the low end and might have outliers\non the high end. It's not very general purpose but it's ideal for distributions that have a long-fat-tail.</p>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>rows</span> : Object[]<div class='sub-desc'>\n</div></li><li><span class='pre'>valueField</span> : String<div class='sub-desc'><p>Specifies the field containing the values to calculate the histogram on</p>\n</div></li><li><span class='pre'>noClipping</span> : Boolean (optional)<div class='sub-desc'><p>If set to true, then it will not create a non-linear band for the outliers. The\n default behavior (noClipping = false) is to lump together outliers into a single bucket at the top.</p>\n<p>Defaults to: <code>false</code></p></div></li></ul><h3 class='pa'>Returns</h3><ul><li><span class='pre'>Object[]</span><div class='sub-desc'><p>Returns an object containing the following:</p>\n\n<ul>\n<li>buckets - An Array containing {label, count, rows, clippedChartValue}</li>\n<li>bucketSize - The size of each bucket (except the top one)</li>\n<li>chartMax - The maximum to use for charting using clipped values</li>\n<li>clipped - A Boolean indicating if the result is clipped</li>\n<li>valueMax - The actual maximum value found. Will always be >= chartMax</li>\n</ul>\n\n\n<p>Given an array of rows like:</p>\n\n<pre><code>{histogram} = require('../')\n\nrows = [\n  {age:  7},\n  {age: 25},\n  {age: 23},\n  {age: 27},\n  {age: 34},\n  {age: 55},\n  {age: 42},\n  {age: 13},\n  {age: 11},\n  {age: 23},\n  {age: 31},\n  {age: 32},\n  {age: 29},\n  {age: 16},\n  {age: 31},\n  {age: 22},\n  {age: 25},\n]\n</code></pre>\n\n<p>histogram will calculate a histogram. There will be sqrt(n) + 1 buckets</p>\n\n<pre><code>{buckets, chartMax} = histogram.clipping(rows, 'age')\nfor b in buckets\n  console.log(b.label, b.count)\n# 0-12 2\n# 12-24 5\n# 24-36 8\n# 36-48 1\n# 48-60 1\n\nconsole.log(chartMax)\n# 60\n</code></pre>\n\n<p>This histogram calculator will also attempt to lump outliers into a single bucket at the top.</p>\n\n<pre><code>rows.push({age: 85})\n\n{buckets, chartMax} = histogram.clipping(rows, 'age')\n\nlastBucket = buckets[buckets.length - 1]\nconsole.log(lastBucket.label, lastBucket.count)\n# 48-86* 2\n</code></pre>\n\n<p>The asterix <code>*</code> is there to indicate that this bucket is not the same size as the others and non-linear.\nThe histogram calculator will also \"clip\" the values for these outliers so that you can\ndisplay them in a scatter chart on a linear scale with the last band compressed.\nThe <code>clippedChartValue</code> will be guaranteed to be below the <code>chartMax</code> by interpolating it's position between\nthe bounds of the top band where the actual max value is scaled down to the <code>chartMax</code></p>\n\n<pre><code>lastBucket = buckets[buckets.length - 1]\nconsole.log(lastBucket.rows[1].age, lastBucket.rows[1].clippedChartValue)\n# 85 59.68421052631579\n</code></pre>\n</div></li></ul></div></div></div></div><div class='subsection'><div class='definedBy'>Defined By</div><h4 class='members-subtitle'>Static Methods</h3><div id='static-method-bucket' class='member first-child not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='Lumenize.histogram'>Lumenize.histogram</span><br/><a href='source/histogram.coffee.html#Lumenize-histogram-static-method-bucket' target='_blank' class='view-source'>view source</a></div><a href='#!/api/Lumenize.histogram-static-method-bucket' class='name expandable'>bucket</a>( <span class='pre'>value, buckets</span> ) : Object<strong class='static signature' >static</strong></div><div class='description'><div class='short'> ...</div><div class='long'>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>value</span> : Number<div class='sub-desc'><p>The value to bucket</p>\n</div></li><li><span class='pre'>buckets</span> : Object[]<div class='sub-desc'><p>Array of objects where each row is in the form {index, startOn, endBelow, label}</p>\n</div></li></ul><h3 class='pa'>Returns</h3><ul><li><span class='pre'>Object</span><div class='sub-desc'><p>Returns the bucket that contains the given value</p>\n</div></li></ul></div></div></div><div id='static-method-getBuckets' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='Lumenize.histogram'>Lumenize.histogram</span><br/><a href='source/histogram.coffee.html#Lumenize-histogram-static-method-getBuckets' target='_blank' class='view-source'>view source</a></div><a href='#!/api/Lumenize.histogram-static-method-getBuckets' class='name expandable'>getBuckets</a>( <span class='pre'>rows, [valueField], [type], [significance], [firstStartOn], [lastEndBelow], [bucketCount]</span> ) : Object[]<strong class='static signature' >static</strong></div><div class='description'><div class='short'> ...</div><div class='long'>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>rows</span> : Object[]/Number[]<div class='sub-desc'><p>If no valueField is provided or the valueField parameter is null, then the first parameter is\nassumed to be an Array of Numbers representing the values to bucket. Otherwise, it is assumed to be an Array of Objects\nwith a bunch of fields.</p>\n</div></li><li><span class='pre'>valueField</span> : String (optional)<div class='sub-desc'><p>Specifies the field containing the values to calculate the histogram on</p>\n</div></li><li><span class='pre'>type</span> : function (optional)<div class='sub-desc'><p>Specifies how to pick the edges of the buckets. Three standard schemes\n  are provided: histogram.bucketsConstantWidth, histogram.bucketsConstantDepth, and histogram.bucketsVOptimal.\n  However, you can inject your own.</p>\n<p>Defaults to: <code>histogram.constantWidth</code></p></div></li><li><span class='pre'>significance</span> : Number (optional)<div class='sub-desc'><p>The multiple to which you want to round the bucket edges. 1 means whole numbers.\n 0.1 means to round to tenths. 0.01 to hundreds. Etc. If you provide all of these last four parameters, ensure\n that (lastEndBelow - firstStartOn) / bucketCount will naturally come out in the significance specified. So,\n (100 - 0) / 100 = 1. This works well with a significance of 1, 0.1, 0.01, etc. But (13 - 0) / 10  = 1.3. This\n would not work with a significance of 1. However, a signficance of 0.1 would work fine.</p>\n</div></li><li><span class='pre'>firstStartOn</span> : Number (optional)<div class='sub-desc'><p>This will be the endBefore of the first bucket. Think of it as the min value.</p>\n</div></li><li><span class='pre'>lastEndBelow</span> : Number (optional)<div class='sub-desc'><p>This will be the startOn of the last bucket. Think of it as the max value.</p>\n</div></li><li><span class='pre'>bucketCount</span> : Number (optional)<div class='sub-desc'><p>If provided, the histogram will have this many buckets.</p>\n</div></li></ul><h3 class='pa'>Returns</h3><ul><li><span class='pre'>Object[]</span><div class='sub-desc'><p>Returns an Array of Objects (buckets) in the form of {index, startOn, endBelow, label}</p>\n\n<p>The buckets array that is returned will have these properties:</p>\n\n<ul>\n<li>Each bucket (row) will have these fields {index, startOn, endBelow, label}.</li>\n<li>If firstStartOn is not provided, it will be -Infinity</li>\n<li>If lastEndBelow is not provided, it will be Infinity.</li>\n</ul>\n\n</div></li></ul></div></div></div><div id='static-method-histogramFromBuckets' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='Lumenize.histogram'>Lumenize.histogram</span><br/><a href='source/histogram.coffee.html#Lumenize-histogram-static-method-histogramFromBuckets' target='_blank' class='view-source'>view source</a></div><a href='#!/api/Lumenize.histogram-static-method-histogramFromBuckets' class='name expandable'>histogramFromBuckets</a>( <span class='pre'>rows, valueField, buckets</span> ) : function<strong class='static signature' >static</strong></div><div class='description'><div class='short'> ...</div><div class='long'>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>rows</span> : Object[]<div class='sub-desc'>\n</div></li><li><span class='pre'>valueField</span> : String<div class='sub-desc'><p>Specifies the field containing the values to calculate the histogram on</p>\n</div></li><li><span class='pre'>buckets</span> : Object[]<div class='sub-desc'><p>Array of Objects as output from a get...Buckets() function. Each row {index, startOn, endBelow, label}</p>\n</div></li></ul><h3 class='pa'>Returns</h3><ul><li><span class='pre'>function</span><div class='sub-desc'><p>Returns a histogram from rows using the provided buckets. If a valueField is provided then it will extract the values from\nthat field in the rows parameter. If not, it will assume that the rows parameter is an Array of Numbers containing\nthe values to histogram. This function returns a <Histogram> which is an Array of Objects where each row is in this form\n{index, startOn, endBelow, label, count}.</p>\n</div></li></ul></div></div></div></div></div></div></div>"});