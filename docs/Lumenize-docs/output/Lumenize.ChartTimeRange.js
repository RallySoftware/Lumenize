Ext.data.JsonP.Lumenize_ChartTimeRange({"tagname":"class","name":"Lumenize.ChartTimeRange","extends":null,"mixins":[],"alternateClassNames":[],"aliases":{},"singleton":false,"requires":[],"uses":[],"enum":null,"override":null,"inheritable":null,"inheritdoc":null,"meta":{},"private":null,"id":"class-Lumenize.ChartTimeRange","members":{"cfg":[],"property":[],"method":[{"name":"constructor","tagname":"method","owner":"Lumenize.ChartTimeRange","meta":{},"id":"method-constructor"},{"name":"contains","tagname":"method","owner":"Lumenize.ChartTimeRange","meta":{},"id":"method-contains"},{"name":"getAll","tagname":"method","owner":"Lumenize.ChartTimeRange","meta":{},"id":"method-getAll"},{"name":"getIterator","tagname":"method","owner":"Lumenize.ChartTimeRange","meta":{},"id":"method-getIterator"},{"name":"getTimeline","tagname":"method","owner":"Lumenize.ChartTimeRange","meta":{},"id":"method-getTimeline"}],"event":[],"css_var":[],"css_mixin":[]},"linenr":183,"files":[{"filename":"ChartTimeIteratorAndRange.coffee.js","href":"ChartTimeIteratorAndRange.coffee.html#Lumenize-ChartTimeRange"}],"html_meta":{},"statics":{"cfg":[],"property":[],"method":[],"event":[],"css_var":[],"css_mixin":[]},"component":false,"superclasses":[],"subclasses":[],"mixedInto":[],"parentMixins":[],"html":"<div><pre class=\"hierarchy\"><h4>Files</h4><div class='dependency'><a href='source/ChartTimeIteratorAndRange.coffee.html#Lumenize-ChartTimeRange' target='_blank'>ChartTimeIteratorAndRange.coffee.js</a></div></pre><div class='doc-contents'><h1>ChartTimeRange</h1>\n\n<p>Allows you to specify a range for iterating over or identifying if it <code>contains()</code> some other date.\nThis <code>contains()</code> comparision can be done in a timezone sensitive way.</p>\n\n<h2>Usage</h2>\n\n<p>Let's create the <code>spec</code> for our ChartTimeRange</p>\n\n<pre><code>{ChartTimeIterator, ChartTimeRange, ChartTime} = require('../')\n\nr = new ChartTimeRange({\n  startOn:new ChartTime('2011-01-02'),\n  endBefore:new ChartTime('2011-01-07'),\n  holidays: [\n    {month: 1, day: 1},  # Notice the lack of a year specification\n    {year: 2011, month: 1, day: 2}  # Got January 2 off also in 2011\n  ]\n})\n</code></pre>\n\n<p><code>workDays</code> is already defaulted but you could have overridden it.</p>\n\n<pre><code>console.log(r.workDays)\n# [ 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday' ]\n</code></pre>\n\n<p>Now let's get an iterator over this range.</p>\n\n<pre><code>i = r.getIterator('ChartTime')\n\nwhile i.hasNext()\n  console.log(i.next().toString()) \n\n# 2011-01-03\n# 2011-01-04\n# 2011-01-05\n# 2011-01-06\n</code></pre>\n\n<p>Notice how 2011-01-02 was skipped because it was a holiday. Also notice how the endBefore is not included.\nRanges are inclusive of the startOn and exclusive of the endBefore. This allows the endBefore of one to be\nthe startOn of the next with no overlap or gap. This focus on precision pervades the design of the ChartTime library.</p>\n\n<p>Now, let's create a ChartTimeRange with <code>hour</code> granularity to elaborate on this inclusive/exclusive behavior.</p>\n\n<pre><code>r2 = new ChartTimeRange({\n  startOn:new ChartTime('2011-01-02T00'),\n  endBefore:new ChartTime('2011-01-07T00'),\n})\n</code></pre>\n\n<p><code>startOn</code> is inclusive.</p>\n\n<pre><code>console.log(r2.contains(new ChartTime('2011-01-02T00')))\n# true\n</code></pre>\n\n<p>But <code>endBefore</code> is exclusive</p>\n\n<pre><code>console.log(r2.contains(new ChartTime('2011-01-07T00')))\n# false\n</code></pre>\n\n<p>But just before <code>endBefore</code> is OK</p>\n\n<pre><code>console.log(r2.contains('2011-01-06T23'))\n# true\n</code></pre>\n\n<p>In the above line, notice how we omitted the <code>new ChartTime(...)</code>. If you pass in a string without a timezone,\nit will automatically create the ChartTime to do the comparison.</p>\n\n<p>All of the above comparisons assume that the <code>startOn</code>/<code>endBefore</code> boundaries are in the same timezone as the contains date.</p>\n\n<h2>Timezone sensitive comparisions</h2>\n\n<p>Now, let's look at how you do timezone sensitive comparisions.</p>\n\n<p>If you pass in a timezone, then it will shift the CharTimeRange boundaries to that timezone to compare to the\ndate/timestamp that you pass in. This system is optimized to the pattern where you first define your boundaries without regard\nto timezone. Christmas day is a holiday in any timezone. Saturday and Sunday are non work days in any timezone. The iteration\nstarts on July 10th; etc. THEN you have a bunch of data that you have stored in a database in GMT. Maybe you've pulled\nit down from an API but the data is represented with a GMT date/timestamp. You then want to decide if the GMT date/timestamp\nis contained within the iteration as defined by a particular timezone, or is a Saturday, or is during workhours, etc.\nThe key concept to remember is that the timebox boundaries are shifted NOT the other way around. It says at what moment\nin time July 10th starts on in a particular timezone and internally represents that in a way that can be compared to a GMT\ndate/timestamp.</p>\n\n<p>So, when it's 3am in GMT on 2011-01-02, it's still 2011-01-01 in New York. Using the above <code>r2</code> range, we say:</p>\n\n<pre><code>console.log(r2.contains('2011-01-02T03:00:00.000Z', 'America/New_York'))\n# false\n</code></pre>\n\n<p>But it's still 2011-01-06 in New York, when it's 3am in GMT on 2011-01-07</p>\n\n<pre><code>console.log(r2.contains('2011-01-07T03:00:00.000Z', 'America/New_York'))\n# true\n</code></pre>\n\n<p>Now, let's explore how ChartTimeRanges and ChartTimeIterators are used together. Here is a range spec.</p>\n\n<pre><code>r3 = new ChartTimeRange({\n  startOn:new ChartTime('2011-01-06'),\n  endBefore:new ChartTime('2011-01-11'),\n  workDayStartOn: {hour: 9, minute: 0},\n  workDayEndBefore: {hour: 11, minute: 0}  # Very short work day for demo purposes\n})\n</code></pre>\n\n<p>You can ask for an iterator to emit ChartTimeRanges rather than ChartTime values. On each call to <code>next()</code>, the\niterator will give you a new ChartTimeRange with the <code>startOn</code> value set to what you would have gotten had you\nrequested that it emit ChartTimes. The `endBefore' of the emitted ChartTimeRange will be set to the following value.\nThis is how you drill-down from one granularity into a lower granularity.</p>\n\n<p>By default, the granularity of the iterator will equal the <code>startOn</code>/<code>endBefore</code> of the original ChartTimeRange.\nHowever, you can provide a different granularity (<code>hour</code> in the example below) for the iterator if you want\nto drill-down at a lower granularity.</p>\n\n<pre><code>i3 = r3.getIterator('ChartTimeRange', 'hour')\n\nwhile i3.hasNext()\n  subRange = i3.next()\n  console.log(\"Sub range goes from #{subRange.startOn.toString()} to #{subRange.endBefore.toString()}\")\n  subIterator = subRange.getIterator('ChartTime')\n  while subIterator.hasNext()\n    console.log('    Hour: ' + subIterator.next().hour)\n\n# Sub range goes from 2011-01-06T00 to 2011-01-07T00\n#     Hour: 9\n#     Hour: 10\n# Sub range goes from 2011-01-07T00 to 2011-01-10T00\n#     Hour: 9\n#     Hour: 10\n# Sub range goes from 2011-01-10T00 to 2011-01-11T00\n#     Hour: 9\n#     Hour: 10\n</code></pre>\n\n<p>There is a lot going on here, so let's poke at it a bit. First, notice how the second sub-range goes from the 7th to the\n10th. That's because there was a weekend in there. We didn't get hours for the Saturday and Sunday.</p>\n\n<p>The above approach (<code>r3</code>/<code>i3</code>) is useful for some forms of hand generated analysis, but if you are using ChartTime with\nLumenize, it's overkill because Lumenize is smart enough to do rollups based upon the segments that are emitted from the\nlowest granularity ChartTime. So you can just iterate over the lower granularity and Lumenize will automatically manage\nthe drill up/down to day/month/year levels automatically.</p>\n\n<pre><code>r4 = new ChartTimeRange({\n  startOn:'2011-01-06T00',  # Notice how we include the hour now\n  endBefore:'2011-01-11T00',\n  workDayStartOn: {hour: 9, minute: 0},\n  workDayEndBefore: {hour: 11, minute: 0}  # Very short work day for demo purposes\n})\n</code></pre>\n\n<p>Notice how we are able to simply use strings to represent the startOn/endBefore dates. ChartTimeRange automatically constructs\nChartTime objects from those strings. We could have done that in the earlier examples. I chose not to do so to illustrate\nhow ChartTimes are used under the covers.</p>\n\n<pre><code>i4 = r4.getIterator('ChartTime')\n\nwhile i4.hasNext()\n  console.log(i4.next().toString())\n\n# 2011-01-06T09\n# 2011-01-06T10\n# 2011-01-07T09\n# 2011-01-07T10\n# 2011-01-10T09\n# 2011-01-10T10\n</code></pre>\n\n<p><code>r4</code>/<code>i4</code> covers the same ground as <code>r3</code>/<code>i3</code> but without the explicit nesting.</p>\n</div><div class='members'><div class='members-section'><div class='definedBy'>Defined By</div><h3 class='members-title icon-method'>Methods</h3><div class='subsection'><div id='method-constructor' class='member first-child not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='Lumenize.ChartTimeRange'>Lumenize.ChartTimeRange</span><br/><a href='source/ChartTimeIteratorAndRange.coffee.html#Lumenize-ChartTimeRange-method-constructor' target='_blank' class='view-source'>view source</a></div><strong class='new-keyword'>new</strong><a href='#!/api/Lumenize.ChartTimeRange-method-constructor' class='name expandable'>Lumenize.ChartTimeRange</a>( <span class='pre'>spec</span> ) : <a href=\"#!/api/Lumenize.ChartTimeRange\" rel=\"Lumenize.ChartTimeRange\" class=\"docClass\">Lumenize.ChartTimeRange</a></div><div class='description'><div class='short'> ...</div><div class='long'>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>spec</span> : Object<div class='sub-desc'><p>spec can have the following properties:</p>\n\n<ul>\n<li><strong>startOn</strong> is a ChartTime object or a string. The first value that next() returns.</li>\n<li><strong>endBefore</strong> is a ChartTime object or string. Must match granularity. hasNext() returns false when current is here or later.</li>\n<li><strong>skip</strong> is an optional num. Defaults to 1 or -1. Use -1 to march backwards from endBefore - 1. Currently any\n values other than 1 and -1 give unexpected behavior.</li>\n<li><strong>granularity</strong> is used to determine the granularity that you will iterate over. Note, you can have granularity of say month\n for the startOn and/or endBefore but have a finer granularity for the range. Let's say you want to iterate over all the days\n of the current month. In this case, endBefore would be 'next month', and startOn would be 'prior month'.</li>\n<li><strong>limit</strong> you can specify limit plus one of startOn/endBefore and only get back this many.</li>\n<li><strong>workDays</strong> list of days of the week that you work on. Either ['Monday', 'Tuesday', ...] or \"Monday,Tuesday,...\"\n Defaults to ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday'].</li>\n<li><strong>holidays</strong> is an optional Array like: [{month: 12, day: 25}, {year: 2011, month: 11, day: 24}]. Notice how\n you can leave off the year if the holiday falls on the same day every year.</li>\n<li><strong>workDayStartOn</strong> is an optional object in the form {hour: 8, minute: 15}. Must include minute even when 0.\n If workDayStartOn is later than workDayEndBefore, then it assumes that you work the night shift and your work\n hours span midnight.</li>\n<li><strong>workDayEndBefore</strong> is an optional object in the form {hour: 17, minute: 0}. Must include minute even when 0.\n The use of workDayStartOn and workDayEndBefore only make sense when the granularity is \"hour\" or finer.\n Note: If the business closes at 5:00pm, you'll want to leave workDayEndBefore to 17:00, rather\n than 17:01. Think about it, you'll be open 4:59:59.999pm, but you'll be closed at 5:00pm. This also makes all of\n the math work. 9am to 5pm means 17 - 9 = an 8 hour work day.</li>\n</ul>\n\n</div></li></ul><h3 class='pa'>Returns</h3><ul><li><span class='pre'><a href=\"#!/api/Lumenize.ChartTimeRange\" rel=\"Lumenize.ChartTimeRange\" class=\"docClass\">Lumenize.ChartTimeRange</a></span><div class='sub-desc'>\n</div></li></ul></div></div></div><div id='method-contains' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='Lumenize.ChartTimeRange'>Lumenize.ChartTimeRange</span><br/><a href='source/ChartTimeIteratorAndRange.coffee.html#Lumenize-ChartTimeRange-method-contains' target='_blank' class='view-source'>view source</a></div><a href='#!/api/Lumenize.ChartTimeRange-method-contains' class='name expandable'>contains</a>( <span class='pre'>date, [tz]</span> ) : Boolean</div><div class='description'><div class='short'> ...</div><div class='long'>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>date</span> : ChartTime/Date/String<div class='sub-desc'><p>can be either a JavaScript date object or an ISO-8601 formatted string</p>\n</div></li><li><span class='pre'>tz</span> : String (optional)<div class='sub-desc'>\n</div></li></ul><h3 class='pa'>Returns</h3><ul><li><span class='pre'>Boolean</span><div class='sub-desc'><p>true if the date provided is within this ChartTimeRange.</p>\n\n<h2>Usage:</h2>\n\n<p>We can create a range from May to July.</p>\n\n<pre><code>r = new ChartTimeRange({\n  startOn: '2011-05',\n  endBefore: '2011-07'\n})\n\nconsole.log(r.contains('2011-06-15T12:00:00.000Z', 'America/New_York'))\n# true\n</code></pre>\n</div></li></ul></div></div></div><div id='method-getAll' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='Lumenize.ChartTimeRange'>Lumenize.ChartTimeRange</span><br/><a href='source/ChartTimeIteratorAndRange.coffee.html#Lumenize-ChartTimeRange-method-getAll' target='_blank' class='view-source'>view source</a></div><a href='#!/api/Lumenize.ChartTimeRange-method-getAll' class='name expandable'>getAll</a>( <span class='pre'>[emit], [childGranularity], [tz]</span> ) : ChartTime[]/Date[]/ChartTimeRange[]</div><div class='description'><div class='short'> ...</div><div class='long'>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>emit</span> : String (optional)<div class='sub-desc'>\n</div></li><li><span class='pre'>childGranularity</span> : String (optional)<div class='sub-desc'>\n</div></li><li><span class='pre'>tz</span> : String (optional)<div class='sub-desc'>\n</div></li></ul><h3 class='pa'>Returns</h3><ul><li><span class='pre'>ChartTime[]/Date[]/ChartTimeRange[]</span><div class='sub-desc'><p>Returns all of the points in the timeline specified by this ChartTimeRange.</p>\n\n<p>Note, to maintain backward compatibility with the time before ChartTimeRange existed, the default for emit when\ninstantiating a new ChartTimeIterator directly is 'ChartTime'. However, if you request a new ChartTimeIterator\nfrom a ChartTimeRange object using getIterator(), the default is 'ChartTimeRange'.</p>\n</div></li></ul></div></div></div><div id='method-getIterator' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='Lumenize.ChartTimeRange'>Lumenize.ChartTimeRange</span><br/><a href='source/ChartTimeIteratorAndRange.coffee.html#Lumenize-ChartTimeRange-method-getIterator' target='_blank' class='view-source'>view source</a></div><a href='#!/api/Lumenize.ChartTimeRange-method-getIterator' class='name expandable'>getIterator</a>( <span class='pre'>[emit], [childGranularity], [tz]</span> ) : ChartTimeIterator</div><div class='description'><div class='short'> ...</div><div class='long'>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>emit</span> : String (optional)<div class='sub-desc'>\n</div></li><li><span class='pre'>childGranularity</span> : String (optional)<div class='sub-desc'>\n</div></li><li><span class='pre'>tz</span> : String (optional)<div class='sub-desc'>\n</div></li></ul><h3 class='pa'>Returns</h3><ul><li><span class='pre'>ChartTimeIterator</span><div class='sub-desc'><p>Returns a new ChartTimeIterator using this ChartTimeRange as the boundaries.</p>\n\n<p>Note, to maintain backward compatibility with the time before ChartTimeRange existed, the default for emit when\ninstantiating a new ChartTimeIterator directly is 'ChartTime'. However, if you request a new ChartTimeIterator\nfrom a ChartTimeRange object using getIterator(), the default is 'ChartTimeRange'.</p>\n</div></li></ul></div></div></div><div id='method-getTimeline' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='Lumenize.ChartTimeRange'>Lumenize.ChartTimeRange</span><br/><a href='source/ChartTimeIteratorAndRange.coffee.html#Lumenize-ChartTimeRange-method-getTimeline' target='_blank' class='view-source'>view source</a></div><a href='#!/api/Lumenize.ChartTimeRange-method-getTimeline' class='name expandable'>getTimeline</a>( <span class='pre'></span> ) : ChartTime[]</div><div class='description'><div class='short'> ...</div><div class='long'>\n<h3 class='pa'>Returns</h3><ul><li><span class='pre'>ChartTime[]</span><div class='sub-desc'><p>Returns all of the points in the timeline specified by this ChartTimeRange as ChartTime objects. This method also\nmakes sure that the array that is returned is sorted chrologically.</p>\n</div></li></ul></div></div></div></div></div></div></div>"});