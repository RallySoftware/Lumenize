<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">/* &lt;CoffeeScript&gt;
utils = require('./utils')

&lt;/CoffeeScript&gt; */
<span id='Lumenize-functions'>/**
</span> * @class Lumenize.functions
 */
/* &lt;CoffeeScript&gt;
functions = {}

###
@var {String[]} functions.INCREMENTAL A list of the function names that can be calculated incrementally
###
functions.INCREMENTAL = ['sum', 'sumSquares', 'lastValue', 'count', 'min', 'max', 'values', 'uniqueValues']

&lt;/CoffeeScript&gt; */
<span id='Lumenize-functions-static-method-sum'>/**
</span> * @method sum
 * @member Lumenize.functions
 * @static
 * @param {Number[]} values
 * @param {Number} [oldResult] for incremental calculation
 * @param {Number[]} [newValues] for incremental calculation
 * @return {Number} The sum of the values
 */
/* &lt;CoffeeScript&gt;
functions.sum = (values, oldResult, newValues) -&gt;
  if oldResult?
    temp = oldResult
    tempValues = newValues
  else
    temp = 0
    tempValues = values
  for v in tempValues
    temp += v
  return temp

&lt;/CoffeeScript&gt; */
<span id='Lumenize-functions-static-method-sumSquares'>/**
</span> * @method sumSquares
 * @member Lumenize.functions
 * @static
 * @param {Number[]} values
 * @param {Number} [oldResult] for incremental calculation
 * @param {Number[]} [newValues] for incremental calculation
 * @return {Number} The sum of the squares of the values
 */
/* &lt;CoffeeScript&gt;
functions.sumSquares = (values, oldResult, newValues) -&gt;
  if oldResult?
    temp = oldResult
    tempValues = newValues
  else
    temp = 0
    tempValues = values
  for v in tempValues
    temp += v * v
  return temp

&lt;/CoffeeScript&gt; */
<span id='Lumenize-functions-static-method-lastValue'>/**
</span> * @method lastValue
 * @member Lumenize.functions
 * @static
 * @param {Number[]} values
 * @param {Number} [oldResult] Not used. It is included to make the interface consistent.
 * @param {Number[]} [newValues] for incremental calculation
 * @return {Number} The last value
 */
/* &lt;CoffeeScript&gt;
functions.lastValue = (values, oldResult, newValues) -&gt;
  if newValues?
    return newValues[newValues.length - 1]
  return values[values.length - 1]

&lt;/CoffeeScript&gt; */
<span id='Lumenize-functions-static-method-count'>/**
</span> * @method count
 * @member Lumenize.functions
 * @static
 * @param {Number[]} values
 * @param {Number} [oldResult] for incremental calculation
 * @param {Number[]} [newValues] for incremental calculation
 * @return {Number} The length of the values Array
 */
/* &lt;CoffeeScript&gt;
functions.count = (values, oldResult, newValues) -&gt;
  if oldResult?
    return oldResult + newValues.length
  return values.length

&lt;/CoffeeScript&gt; */
<span id='Lumenize-functions-static-method-min'>/**
</span> * @method min
 * @member Lumenize.functions
 * @static
 * @param {Number[]} values
 * @param {Number} [oldResult] for incremental calculation
 * @param {Number[]} [newValues] for incremental calculation
 * @return {Number} The minimum value or null if no values
 */
/* &lt;CoffeeScript&gt;
functions.min = (values, oldResult, newValues) -&gt;
  if oldResult?
    return functions.min(newValues.concat([oldResult]))
  if values.length == 0
    return null
  temp = values[0]
  for v in values
    if v &lt; temp
      temp = v
  return temp

&lt;/CoffeeScript&gt; */
<span id='Lumenize-functions-static-method-max'>/**
</span> * @method max
 * @member Lumenize.functions
 * @static
 * @param {Number[]} values
 * @param {Number} [oldResult] for incremental calculation
 * @param {Number[]} [newValues] for incremental calculation
 * @return {Number} The maximum value or null if no values
 */
/* &lt;CoffeeScript&gt;
functions.max = (values, oldResult, newValues) -&gt;
  if oldResult?
    return functions.max(newValues.concat([oldResult]))
  if values.length == 0
    return null
  temp = values[0]
  for v in values
    if v &gt; temp
      temp = v
  return temp

&lt;/CoffeeScript&gt; */
<span id='Lumenize-functions-static-method-values'>/**
</span> * @method values
 * @member Lumenize.functions
 * @static
 * @param {Object[]} values
 * @param {Number} [oldResult] for incremental calculation
 * @param {Number[]} [newValues] for incremental calculation
 * @return {Array} All values (allows duplicates). Can be used for drill down when you know they will be unique.
 */
/* &lt;CoffeeScript&gt;
functions.values = (values, oldResult, newValues) -&gt;
  if oldResult?
    return oldResult.concat(newValues)
  return values
#  temp = []
#  for v in values
#    temp.push(v)
#  return temp

&lt;/CoffeeScript&gt; */
<span id='Lumenize-functions-static-method-uniqueValues'>/**
</span> * @method uniqueValues
 * @member Lumenize.functions
 * @static
 * @param {Object[]} values
 * @param {Number} [oldResult] for incremental calculation
 * @param {Number[]} [newValues] for incremental calculation
 * @return {Array} Unique values. This is good for generating an OLAP dimension or drill down.
 */
/* &lt;CoffeeScript&gt;
functions.uniqueValues = (values, oldResult, newValues) -&gt;
  temp = {}
  if oldResult?
    for r in oldResult
      temp[r] = null
    tempValues = newValues
  else
    tempValues = values
  temp2 = []
  for v in tempValues
    temp[v] = null
  for key, value of temp
    temp2.push(key)
  return temp2

&lt;/CoffeeScript&gt; */
<span id='Lumenize-functions-static-method-average'>/**
</span> * @method average
 * @member Lumenize.functions
 * @static
 * @param {Number[]} values
 * @return {Number} The arithmetic mean
 */
/* &lt;CoffeeScript&gt;
functions.average = (values) -&gt;
  count = values.length
  sum = 0
  for v in values
    sum += v
  return sum / count

&lt;/CoffeeScript&gt; */
<span id='Lumenize-functions-static-method-variance'>/**
</span> * @method variance
 * @member Lumenize.functions
 * @static
 * @param {Number[]} values
 * @return {Number} The variance
 */
/* &lt;CoffeeScript&gt;
functions.variance = (values) -&gt;
  n = values.length
  sum = 0
  sumSquares = 0
  for v in values
    sum += v
    sumSquares += v * v
  return (n * sumSquares - sum * sum) / (n * (n - 1))

&lt;/CoffeeScript&gt; */
<span id='Lumenize-functions-static-method-standardDeviation'>/**
</span> * @method standardDeviation
 * @member Lumenize.functions
 * @static
 * @param {Number[]} values
 * @return {Number} The standard deviation
 */
/* &lt;CoffeeScript&gt;
functions.standardDeviation = (values) -&gt;
  return Math.sqrt(functions.variance(values))

&lt;/CoffeeScript&gt; */
<span id='Lumenize-functions-static-method-percentileCreator'>/**
</span> * @method percentileCreator
 * @member Lumenize.functions
 * @static
 * @param {Number} p The percentile for the resulting function (50 = median, 75, 99, etc.)
 * @return {Function} A funtion to calculate the percentile
 * 
 * When the user passes in `p&lt;n&gt;` as an aggregation function, this `percentileCreator` is called to return the appropriate
 * percentile function. The returned function will find the `&lt;n&gt;`th percentile where `&lt;n&gt;` is some number in the form of
 * `##[.##]`. (e.g. `p40`, `p99`, `p99.9`).
 * 
 * Note: `median` is an alias for `p50`.
 * 
 * There is no official definition of percentile. The most popular choices differ in the interpolation algorithm that they
 * use. The function returned by this `percentileCreator` uses the Excel interpolation algorithm which is close to the NIST
 * recommendation and makes the most sense to me.
 */
/* &lt;CoffeeScript&gt;
functions.percentileCreator = (p) -&gt;
  return (values) -&gt;
    sortfunc = (a, b) -&gt;
      return a - b
    vLength = values.length
    values.sort(sortfunc)
    n = (p * (vLength - 1) / 100) + 1
    k = Math.floor(n)
    d = n - k
    if n == 1
      return values[1 - 1]
    if n == vLength
      return values[vLength - 1]
    return values[k - 1] + d * (values[k] - values[k - 1])

functions.extractFandAs = (a, field) -&gt;
&lt;/CoffeeScript&gt; */
<span id='Lumenize-functions-static-method-extractFandAs'>  /**
</span>   * @method extractFandAs
   * @member Lumenize.functions
   * @static
   * @param {Object} a Will look like this `{as: 'mySum', f: 'sum'}`
   * @param {String} field The name of the field this function operates on
   * @return {Object} {f: &lt;executable Function&gt;, as: &lt;String name for calculation&gt;}
   */
/* &lt;CoffeeScript&gt;
  if a.as?
    as = a.as
  else
    utils.assert(utils.type(a.f) != 'function', 'Must provide &quot;as&quot; field with your aggregation when providing a user defined function')
    if a.field?
      field = a.field
    as = &quot;#{field}_#{a.f}&quot;
  if utils.type(a.f) == 'function'
    f = a.f
  else if functions[a.f]?
    f = functions[a.f]
  else if a.f == 'median'
    f = functions.percentileCreator(50)
  else if a.f.substr(0, 1) == 'p'
    p = /\p(\d+(.\d+)?)/.exec(a.f)[1]
    f = functions.percentileCreator(Number(p))
  else
    throw new Error(&quot;#{a.f} is not a recognized built-in function&quot;)
  return {f, as}

exports.functions = functions
&lt;/CoffeeScript&gt; */</pre>
</body>
</html>
