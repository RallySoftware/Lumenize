<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">/* &lt;CoffeeScript&gt;
utils = require('../src/utils')
{functions} = require('../')

&lt;/CoffeeScript&gt; */
<span id='Lumenize-OLAPCube-method-constructor'><span id='Lumenize-OLAPCube-cfg-keepFacts'><span id='Lumenize-OLAPCube-cfg-keepTotals'><span id='Lumenize-OLAPCube-cfg-keepValues'><span id='Lumenize-OLAPCube-cfg-dimensions'><span id='Lumenize-OLAPCube-cfg-metrics'><span id='Lumenize-OLAPCube'>/**
</span></span></span></span></span></span></span> * @class Lumenize.OLAPCube
 * 
 * @constructor
 * @param {Object} config See Config options for details. DO NOT change the config settings after the OLAP class is instantiated.
 * @param {Object[]} [facts] Optional parameter allowing the population of the OLAPCube with an intitial set of facts
 *   upon instantiation. Use addFacts() to add facts after instantiation.
 * @cfg {Object[]} metrics (required) Array which specifies the metrics to calculate for each cell in the cube.
 * 
 *   Here is an example metric definition:
 * 
 *       metrics: [
 *         {field: 'field3'},                                      # defaults to metrics of (count, sum, sumSquares)
 *         {field: 'field4', metrics: [
 *           {f: 'sum'},                                           # will add a metric named field4_sum
 *           {as: 'median4', f: 'p50'},                            # renamed p50 to median4 from default of field4_p50
 *           {as: 'myCount', f: (values) -&gt; return values.length}  # user-supplied function
 *         ]}
 *       ]
 * 
 *   If you do not specify any functions for a metrics field, it will default to count, sum, and sumSquares.
 *   See below for examples.
 * @cfg {Object[]} dimensions (required) Array which specifies the fields to use as dimension fields. If the field contains a
 *   hierarchy array, say so in the row, (e.g. `{field: 'SomeFieldName', type: 'hierarchy'}`). Any array values that it
 *   finds in the supplied facts will be assumed to be tags rather than a hierarchy specification unless `type: 'hierarchy'`
 *   is specified.
 * @cfg {Boolean} [keepValues=false] Setting this will have a similar effect as including `f: &quot;values&quot;` for all metrics fields.
 *   If you are going to incrementally update the OLAPCube, then you are required to set this to true if you are using
 *   any functions other than count, sum, sumSquares, variance, or standardDeviation.
 * @cfg {Boolean} [keepTotals=false] Setting this will add an additional total row (indicated with field: null) along
 *   all dimensions. This setting can have a significant impact on the memory usage and performance of the OLAPCube so
 *   if things are tight, only use it if you really need it.
 * @cfg {Boolean} [keepFacts=false] Setting this will cause the OLAPCube to keep track of the facts that contributed to
 *   the metrics for each cell by adding a __facts field to each cell.
 */
/* &lt;CoffeeScript&gt;
class OLAPCube
    the metrics for each cell by adding a __facts field to each cell.
  constructor: (@config, facts) -&gt;
    @cells = []
    @cellIndex = {}
    @virgin = true
    @_dirtyData = []
    @_dirtyDataIndex = {}

    unless @config.keepValues
      @config.keepValues = false
    unless @config.keepTotals
      @config.keepTotals = false
    unless @config.keepFacts
      @config.keepFacts = false

    # add default metrics if not specified
    for m in @config.metrics
      unless m.metrics?
        m.metrics = [
          {f: 'count'},
          {f: 'sum'},
          {f: 'sumSquares'}
        ]

    # determine if values must be kept
    @mustKeepValuesToAdd = false
    for m in @config.metrics
      hasCount = false
      hasSum = false
      hasSumSquares = false
      for m2 in m.metrics
        switch m2.f
          when 'count'
            hasCount = true
          when 'sum'
            hasSum = true
          when 'sumSquares'
            hasSumSquares = true
      for m2 in m.metrics
        if m2.f in ['count', 'sum', 'sumSquares']
          # do nothing
        else if m2.f == 'average'
          unless hasCount and hasSum
            @mustKeepValuesToAdd = true
        else if m2.f in ['variance', 'standardDeviation']
          unless hasCount and hasSum and hasSumSquares
            @mustKeepValuesToAdd = true
        else
          @mustKeepValuesToAdd = true

    @addFacts(facts)
  
  @_possibilities: (key, type, keepTotals) -&gt;
    switch utils.type(key)
      when 'array'
        if keepTotals
          a = [null]
        else
          a = []
        if type == 'hierarchy'
          len = key.length
          while len &gt; 0
            a.push(key.slice(0, len))
            len--
        else  # assume it's a tag array
          if keepTotals
            a = [null].concat(key)
          else
            a = key
        return a
      when 'string', 'number'
        if keepTotals
          return [null, key]
        else
          return [key]
  
  
  @_decrement: (a, rollover) -&gt;
    i = a.length - 1
    a[i]--
    while a[i] &lt; 0
      a[i] = rollover[i]
      i--
      if i &lt; 0
        return false
      else
        a[i]--
    return true
  
  _expandFact: (fact) -&gt;
    possibilitiesArray = []
    countdownArray = []
    rolloverArray = []
    for d in @config.dimensions
      p = OLAPCube._possibilities(fact[d.field], d.type, @config.keepTotals)
      possibilitiesArray.push(p)
      countdownArray.push(p.length - 1)
      rolloverArray.push(p.length - 1)  # !TODO: If I need some speed, we could calculate the rolloverArray once and make a copy to the countdownArray for each run
  
    out = []
    more = true
    while more
      outRow = {}
      for d, index in @config.dimensions
        outRow[d.field] = possibilitiesArray[index][countdownArray[index]]
      if @config.keepFacts
        outRow.__facts = [fact]
      metricsOut = {}
      for m in @config.metrics
        metricsOut[m.field + '_values'] = [fact[m.field]]
      outRow.__metrics = metricsOut
      out.push(outRow)
      more = OLAPCube._decrement(countdownArray, rolloverArray)
  
    return out
  
  @_extractFilter: (row, dimensions) -&gt;
    out = {}
    for d in dimensions
      out[d.field] = row[d.field]
    return out
  
  _mergeIntoData: (expandedFactArray) -&gt;
    for er in expandedFactArray
      filterString = JSON.stringify(OLAPCube._extractFilter(er, @config.dimensions))
      olapRow = @cellIndex[filterString]
      if olapRow?
        if @config.keepFacts
          olapRow.__facts = olapRow.__facts.concat(er.__facts)
        currentMetrics = olapRow.__metrics
        for key, value of er.__metrics
          unless currentMetrics[key]?
            currentMetrics[key] = []
          currentMetrics[key] = currentMetrics[key].concat(value)
      else
        olapRow = er
        @cellIndex[filterString] = olapRow
        @cells.push(olapRow)

      unless @_dirtyDataIndex[filterString]?
        @_dirtyDataIndex[filterString] = olapRow
        @_dirtyData.push(olapRow)

  @_variance: (count, sum, sumSquares) -&gt;
    return (count * sumSquares - sum * sum) / (count * (count - 1))

  @_standardDeviation: (count, sum, sumSquares) -&gt;
    return Math.sqrt(count, sum, sumSquares)

&lt;/CoffeeScript&gt; */
<span id='Lumenize-OLAPCube-method-addFacts'>  /**
</span>   * @method addFacts
   * @member Lumenize.OLAPCube
   *   Adds facts to the OLAPCube.
   * 
   * @chainable
   * @param {Object[]} facts An Array of facts to be aggregated into OLAPCube. Each fact is a Map where the keys are the field names
   *   and the values are the field values (e.g. `{field1: 'a', field2: 5}`).
   */
/* &lt;CoffeeScript&gt;
  addFacts: (facts) -&gt;

    if utils.type(facts) == 'array'
      if facts.length &lt;= 0
        return
    else
      if facts?
        facts = [facts]
      else
        return

    if not @virgin and @mustKeepValuesToAdd and not @config.keepValues
      throw new Error('Must specify config.keepValues to add facts with this set of metrics.')

    for fact in facts
      expandedFactArray = @_expandFact(fact)
      @_mergeIntoData(expandedFactArray)
  
    # calculate metrics for @cells
    if @config.keepValues or @virgin
      for olapRow in @_dirtyData
        currentMetrics = olapRow.__metrics
        for m in @config.metrics
          currentField = m.field
          currentValues = currentMetrics[currentField + '_values']
          currentCount = null
          currentSum = null
          currentSumSquares = null

          if @mustKeepValuesToAdd
            for m2 in m.metrics
              {f, as} = functions.extractFandAs(m2, currentField)
              currentMetrics[as] = f(currentValues)
          else
            for m2 in m.metrics
              {f, as} = functions.extractFandAs(m2, currentField)
              if m2.f == 'count'
                currentCount = f(currentValues)
                currentMetrics[as] = currentCount
              else if m2.f == 'sum'
                currentSum = f(currentValues)
                currentMetrics[as] = currentSum
              else if m2.f == 'sumSquares'
                currentSumSquares = f(currentValues)
                currentMetrics[as] = currentSumSquares
            for m2 in m.metrics
              {f, as} = functions.extractFandAs(m2, currentField)
              if m2.f == 'average'
                currentMetrics[as] = currentSum / currentCount
              else if m2.f == 'variance'
                currentMetrics[as] = OLAPCube._variance(currentCount, currentSum, currentSumSquares)
              else if m2.f == 'standardDeviation'
                currentMetrics[as] = OLAPCube._standardDeviation(currentCount, currentSum, currentSumSquares)
              else
                unless m2.f in ['count', 'sum', 'sumSquares']
                  currentMetrics[as] = f(currentValues)

          unless @config.keepValues
            delete currentMetrics[currentField + &quot;_values&quot;]

    else  # not @virgin and not @config.keepValues
      for olapRow in @_dirtyData
        currentMetrics = olapRow.__metrics
        for m in @config.metrics
          currentField = m.field
          currentValues = currentMetrics[currentField + '_values']
          currentCount = null
          currentSum = null
          currentSumSquares = null
          for m2 in m.metrics
            {f, as} = functions.extractFandAs(m2, currentField)
            if m2.f == 'count'
              currentCount = currentMetrics[as] + currentValues.length
              currentMetrics[as] = currentCount
            else if m2.f == 'sum'
              currentSum = currentMetrics[as] + functions.sum(currentValues)
              currentMetrics[as] = currentSum
            else if m2.f == 'sumSquares'
              currentSumSquares = currentMetrics[as] + functions.sumSquares(currentValues)
              currentMetrics[as] = currentSumSquares
          for m2 in m.metrics
            {f, as} = functions.extractFandAs(m2, currentField)
            if m2.f == 'average'
              currentMetrics[as] = currentSum / currentCount
            else if m2.f == 'variance'
              currentMetrics[as] = OLAPCube._variance(currentCount, currentSum, currentSumSquares)
            else if m2.f == 'standardDeviation'
              currentMetrics[as] = OLAPCube._standardDeviation(currentCount, currentSum, currentSumSquares)
            else
              unless m2.f in ['count', 'sum', 'sumSquares']
                throw new Error('If we have this error, then we have a bug with sensing the need for @mustKeepValuesToAdd.')

          unless @config.keepValues
            delete currentMetrics[currentField + &quot;_values&quot;]

    @virgin = false
    @_dirtyData = []
    @_dirtyDataIndex = {}
    return this

#  ###
#  @method slice
#  @param {Object[]} dimensions
#  @return {OLAPCube}
#
#  returns a new OLAPCube that is a subset of this OLAPCube with one or more dimensions of only a set value or completely
#  removed.
#  ###
#  slice: (dimensions) -&gt;

&lt;/CoffeeScript&gt; */
<span id='Lumenize-OLAPCube-method-query'>  /**
</span>   * @method query
   * @member Lumenize.OLAPCube
   *   Returns a subset of the cells that match the supplied filter. If you supply a filter that specifies the values for
   *   all dimensions in the OLAPCube, it will use the internal cellIndex to find the one matching cell very efficiently.
   *   All other queries are a full scan of all cells so it may be more efficient to extract a sub cube with only the
   *   dimensions of interest before running a lot of queries like this.
   * @param {Object} filter In the form of `{field1: value1, field2: value2}
   * @return {Object[]} Returns a the cells that match the supplied filter
   */
/* &lt;CoffeeScript&gt;
  query: (filter) -&gt;
    output = []


    return output

exports.OLAPCube = OLAPCube


&lt;/CoffeeScript&gt; */</pre>
</body>
</html>
